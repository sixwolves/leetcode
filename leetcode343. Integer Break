Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

题目大意是说给定一个正整数n，将其拆分成正好等于至少2个正整数相加，使得这几个正整数的乘积最大。

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Example 2:

Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
分析：

上面的两个输入例子还是比较好懂的，这里我们详细进行分析。试几个输入用例，我们会发现，如果可以不分解出1，那么就尽量不分解出1，什么意思呢，比如n=3，那么最大乘积的分解方法是1*2=2，但是不会分解成1*1*1=1，因为乘以1对乘积结果没有影响，还会占用求和，因此，使用带1进行分解是比较“亏”的。

第二个问题是，我们既然已经知道了尽量不要用1进行分解，那么，n满足什么条件可以不用分解呢？

n=2,分解成1*1=1;n=3，分解成1*2=2;n=4，分解成2*2=4。也就是说，当n>=4的时候，分解中就不会带有1。

由此，我们想到一种动态规划算法，声明一个长度为n的数组，dp[i]=w表示使用题目中所描述的分解方法进行分解得到的最大乘积是w。接下来也就是最重要的部分，如何设定初始值以及寻找到状态转移方程。

首先考虑状态转移方程（其实一般的动态规划应该首先考虑初始值，但是这道题比较特殊，因为初始值的设定比较难，而如果从状态转移方程入手就知道应该如何设定初始值）

从dp数组的含义，不难更新dp数组，下面，以一个具体的例子说明如何更新dp数组

n=8，想求出最大分解后的乘积，第一种情况是第一个数是1，然后看剩下的7分解后最大乘积是多少，然后将结果相乘，也就是dp[1]*dp[7];

第二种情况是第一个数是2，然后看剩下的6分解后最大乘积是多少，然后将结果相乘，也就是dp[2]*dp[6];在这里千万不要以为我是把n=8只拆分成两个数，2和6，因为6是否分解取决于dp[6]的决策，从这里就可以看到这是一个典型的由递归转换成的动态规划（因为当前的决策依赖于之前的决策）。

如果看清了这一点，那么dp[8]=max(dp[i]*dp[8-i])，其中i取值1-7

好，抽象出来，对于任意位置i，dp[i]=max(dp[j]*dp[i-j])。由此，我们终于找到了状态转移方程。

最后一个问题，初始值如何设定？

从dp数组的含义我们知道，dp[5]表示将5分解之后得到的最大乘积，应该是2*3，也就是dp[2]*dp[3]，在这里，dp[2]=2。由以上分析知道当n<=3的时候，dp[i]=i。分析到这一层，就不难写出如下的代码了。

    int integerBreak(int n) {
        if (n<=3)
            return n-1;
        vector<int>dp;
        dp.push_back(0);
        dp.push_back(1);
        dp.push_back(2);
        dp.push_back(3);
        int i,j, tempMax = 0;
        for (i = 4; i <= n; i++){
            tempMax = i - 1;
            for (j = 2; j <= i/2;j++)
            if (dp[j] * dp[i - j] > tempMax)
                tempMax = dp[j] * dp[i - j];
            dp.push_back(tempMax);
        }
        return dp.back();
    }
